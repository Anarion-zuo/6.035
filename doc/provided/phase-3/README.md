# Phase 3 -- Code Generation

Code Generation involves producing correct x86-64 assembler code for all Decaf programs. By the end of code generation, you should have a fully working Decaf compiler. You'll be able to write, compile, and execute real programs on a real machine!

## Project Assignment

For Code Generation, your compiler will translate your high-level IR into a low-level IR. Your low-level IR will include structures that more closely match the machine instructions of a modern architecture. Your compiler will then translate your low-level IR into x86-64 assembly code. You should target the subset of the x86-64 ISA defined in the [x86-64 architecture guide](#reference), in the reference section at the bottom of this handout.

__Your generated code must include all runtime checks listed in the [Decaf language specification](../materials/handouts/01-decaf-spec.pdf).__ Additional checks such as integer overflow are not required.

The last two phases, _Dataflow Analysis_ and _Optimization_, will focus on improving the efficiency of the target code generated by your compiler. For this phase, you are not expected to produce great assembly code. In fact, you are _expected_ to produce bad code. When considering tradeoffs, always choose simplicity of implementation over performance.

You are not constrained as to how you go about generating your final assembly code listing. However, we suggest that you follow the general approach presented in lecture.

For this phase, you should focus your creative energies on designing your Control Flow Graph, familiarizing yourself with the target ISA, your machine-code representations of the run-time structures, and generating correct assembly code. Do not try to produce a register allocation scheme; you will be addressing these issues later.

Tip: Make sure you read the x86-64 manual (linked below) to fully understand what each instruction does. __Do not rely solely on the cheat sheet__, especially if code isn't doing what you expect it to.

## Linking External Libraries

Decaf does not have any input/output functions. Part of this phase is to implement the standard x86-64 calling convention for `import` statements, so that you can interface with the outside world. Any function that is called using `import` needs to be linked in separately. `gcc` will link against any standard libraries, such as `printf` (you may need to use the `-l` argument for `gcc` to link some libraries). The testing files provided to you link against the standard C library. If you want to use functions that are not easy to use in Decaf (handle pointers, etc), you are welcome to write your own library calls in `C`, compile them to object files (using `gcc -c`) and then link them in by hand when compiling your assembly.

## Memory Alignment
 
The concept of memory alignment plays a big role in hardware. To say that we require some address to be `n-byte aligned` is to say that we require `address % n = 0`. In other words, the numerical value of the address must be a multiple of `n`.
 
Some instructions require the stack pointer to be 16-byte aligned. You will not need to use these instructions yourself, but __functions in the C standard library often do, including `printf`__.
 
Consider the following assembly:

```s
...
// assume that at this point, %rsp % 16 = 0
pushq $1     // %rsp % 16 = 8, stack pointer is  8 byte aligned, but not 16
pushq $2     // %rsp % 16 = 0, stack pointer is 16 byte aligned
pushq $3     // %rsp % 16 = 8, stack pointer is  8 byte aligned, but not 16
call printf  // we are entering the function while %rsp is NOT 16-byte aligned
```

Recall that every `pushq` decrements the stack pointer by 8 bytes. This maintains the invariant that `%rsp` is 8-byte aligned at all times, but not necessarily 16-byte aligned. So if you call a foreign functions that expects `%rsp` to be 16-byte aligned and your stack pointer is not 16-byte aligned when you call it, __it may segfault__.

For this project, you can just make sure that the stack pointer is always 16-byte aligned whenever you perform a method call.

## Submission

As a reminder, the documentation will count towards 20% of your project grade. __Refer to the [project overview][project info]__ to understand what is required of the writeup. In short, the writeup will be used to help us understand your code, convince us it's sufficiently general, and let us know anything that might not be reflected in your code. For this phase, the writeup should be just a few pages long. Of course, writing clean/easy-to-understand/well-commented code can save you a lot of work on the documentation.

Submitted repositories should have the following structure:

```txt
<repo name>
├── build.sh
├── run.sh
├── doc/
│   └── phase3.pdf  // phase 3 writeup, described in project overview
└── ...
```

You should be able to run your compiler from the command line with:

```
./run.sh --target=assembly <INPUT FILE> -o <OUTPUT FILE>
```

Your compiler should then write a x86-64 assembly listing to the output file specified by `-o`, or to stdout if `-o` isn't provided.

Nothing should be written to standard error for a syntactically and semantically correct program (or to standard output, if an output file is specified) unless the `--debug` flag is present. If the `--debug` flag is present, your compiler should still run and produce the same resulting assembly listing. Any debugging output is left to your own discretion. All errors should be written to standard error.

We will run your compilers on the test cases in the tests repository. We strongly recommend you write additional tests of your own, because the provided tests are nowhere near comprehensive.

Use the same procedure as in [phase 1](../phase-1/README.md#submission) to submit, but this time to the branch `phase3-submission`.

## Running Tests

Tests for this phase have been released:

```bash
cd tests
git pull origin master
```

As usual, you can run tests using the test script:

```
./tests/test.py codegen
./tests/test.py codegen -f 00-empty
```

By default, the test script writes the executable to a temporary directory, which gets deleted when the script terminates. You can force it to write to a permanent directory by specifying `-D`:

```
./tests/test.py codegen -f 00-empty -D test-workspace
```

Now, you can navigate into `test-workspace` and use `gdb prog` to step through the executable, or read `prog.s` to see the generated assembly code. The program will use access relative paths in later phases, so make sure you `cd` into the directory where the executable is in before running it.

Internally, your assembly code is assembled using the following command:

```
gcc -no-pie -O0 <input file> -o <output executable>
```

As usual, you can run your executable with `./<executable>` and print its return code with `echo $?`. Note that `echo $?` prints the return code of the most recent command, so you should run it only immediately after running your exectuable (e.g. don't run it twice).

## Using GDB

GDB is a tool that allows you to step through your program and inspect memory contents for debugging. Run it with `gdb prog`, then type `start` to begin. This brings you to the start of the `main` function.

Before proceeding, type `layout asm` to bring up a view of your current position in the assembly code. You should be able to correlate this with your generated assembly in `prog.s`. You can navigate around the assembly code with the up and down buttons, though it doesn't always work.

Sometimes, if your program writes to stdout or stderr, the interface can get messed up. When this happens, just type `Ctrl-X A` (`Ctrl-X` followed by `A`) twice, to switch out of assembly view and back again.

At any point, you can view register contents by typing `info reg`, and stack contents by typing `x/16x $rsp`. That last command is actually a general way to inspect memory. The command `x/<num>x <addr>` examines `num` words starting from address `addr`. The second `x` in the command means to print it in hexadecimal; you can change it to `d` for decimal, for example.

Finally, you can use `si` to step forward by one assembly instruction, `finish` to skip to and take the `ret` in a function call, and `ni` to jump over a function call. At any point, you can start the program over by typing `start`, or quit by typing `quit`.

## References

1. [x64 wiki](https://en.wikibooks.org/wiki/X86_Assembly/X86_Instructions)
1. [x64 cheat sheet](https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf) -- lists and tables detailing registers and assembly commands
1. [x86-64 architecture guide](http://6.035.scripts.mit.edu/fa18/x86-64-architecture-guide.html) -- a walkthrough with an example, and common commands
1. [Intel x64 manual](https://software.intel.com/en-us/articles/intel-sdm)
1. [Intel developer manual](https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf) -- detailed description of some assembly instructions

## Assembly Examples


### Example 1

> print `32` using the `printf` function in the standard C library

```s
format_str_0:
    .string "%d\n"  # string constant
    .align 16

.globl main
main:
    # pre-call ritual
    pushq %rbp         # save base pointer
    movq  %rsp, %rbp   # save stack pointer

    # call function `printf`
    leaq format_str_0(%rip), %rdi  # 1st arg; load the address of str constant into %rdi
    movq $32, %rsi                 # 2nd arg; load int constant into %rsi
    call printf                    # call with the above args

    # analogous to 'return 0;' in C's main
    mov $0, %rax

    # post-call ritual
    movq %rbp, %rsp
    popq %rbp
    ret  # return to where the function was called
```

### Example 2

> a function `calc(a, b, c, d, e)` which returns `(a*b - c/d)*e` where `c/d` discards remainders; for example `3/2 = 1`

```s
format_str_0:
    .string "%d\n"  # string constant
    .align 16

calc:
    # pre-call ritual
    pushq %rbp
    movq  %rsp, %rbp

    # %rsi = %rdi * %rsi; calculate a * b
    imul %rdi, %rsi

    # %rax = %rdx / %rcx; calculate c / d
    movq %rdx, %rax  # move %rdx into %rax
    xor  %rdx, %rdx  # zero-out %rdx by xor'ing it with itself
    idiv %rcx        # %rax = %rdx:%rax / %rcx = %rax / %rcx since %rdx = 0

    # %rsi = %rsi - %rax; calculate a*b - c/d
    subq %rax, %rsi

    # %rsi = %rsi * %r8; calculate (a*b - c/d) * e
    imul %r8, %rsi
    
    # move the final value into %rax to return it
    movq %rsi, %rax

    # post-call ritual
    movq %rbp, %rsp
    popq %rbp
    ret

.globl main 
main:
    # pre-call ritual
    pushq %rbp         # save base pointer
    movq  %rsp, %rbp   # save stack pointer

    # calculate (4*5 - 3/2)*1
    movq $4, %rdi  # 1st arg; a=4
    movq $5, %rsi  # 2nd arg; b=5
    movq $3, %rdx  # 3rd arg; c=3
    movq $2, %rcx  # 4th arg; d=2
    movq $1, %r8   # 5th arg; e=1
    call calc # retval = 19 is now in %rax

    # call function `printf`
    leaq format_str_0(%rip), %rdi  # 1st arg; load the address of str constant into %rdi
    movq %rax, %rsi                # 2nd arg; load result of calc into %rsi
    call printf                    # call with the above args

    # analogous to 'return 0;' in C's main
    mov $0, %rax

    # post-call ritual
    movq %rbp, %rsp
    popq %rbp
    ret  # return to where the function was called
```
### Example 3 

> translate the following decaf code

```cpp
import printf;

int a[10]; // global array

void main ( ) {
  int i;
  for (i = 0; i < len(a); i++) {
      printf("%d\n", a[i]);
  }
}
```

```s
.data
format_str_0:
    .string  "%d\n"
    .align 16

    .comm array_0, 88, 16
    .align 16

.text
.globl main
main:
    pushq %rbp
    movq  %rsp, %rbp
    subq   $16, %rsp

    movq $0, -8(%rbp)  # i = 0

    movq $10, array_0       # length
    movq  $0, array_0 + 8
    movq  $0, array_0 + 16
    movq  $0, array_0 + 24
    movq  $0, array_0 + 32
    movq  $0, array_0 + 40
    movq  $0, array_0 + 48
    movq  $0, array_0 + 56
    movq  $0, array_0 + 64
    movq  $0, array_0 + 72
    movq  $0, array_0 + 80

cond_start:
    movq -8(%rbp), %rdi  # %rdi = i
    movq array_0,  %rsi  # %rsi = array_0 = length

stop:
    cmp %rsi, %rdi  # weird syntax
    jge loop_done   # if %rdi >= %rsi = i >= len, exit loop

loop_start:
    # save registers
    push %rdi
    push %rsi
    push %rdx
    push %rcx
    push %r8
    push %r9
    push %r10
    push %r11

    addq $1, %rdi                  # add 1 to compensate for the first element being length
    imul $8, %rdi                  # convert to bytes
    movq      array_0(%rdi), %rsi  # address of array_0 + value in %rdi = array_0 + %rdi = array_0 + i * 8 = array_0[i]
    leaq format_str_0(%rip), %rdi  # pointer to string
    call printf

    # restore registers
    popq %r11
    popq %r10
    popq %r9
    popq %r8
    popq %rcx
    popq %rdx
    popq %rsi
    popq %rdi

    addq $1, -8(%rbp)  # i++
    jmp cond_start

loop_done:
    mov    $0, %rax
    movq %rbp, %rsp
    popq %rbp
    ret
```

[project info]: ../materials/handouts/01-project-overview.pdf
